{
  "name": "Weekend Watchlist - Quality Recommendations",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 18 * * 5"
            }
          ]
        }
      },
      "id": "friday-trigger",
      "name": "Friday Watchlist (6 PM ET)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://www.reddit.com/r/MovieSuggestions/top.json?t=week&limit=30",
        "options": {
          "timeout": 15000
        }
      },
      "id": "fetch-movie-suggestions",
      "name": "Fetch r/MovieSuggestions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 200]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://www.reddit.com/r/NetflixBestOf/top.json?t=week&limit=30",
        "options": {
          "timeout": 15000
        }
      },
      "id": "fetch-netflix-best",
      "name": "Fetch r/NetflixBestOf",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 350]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://www.reddit.com/r/televisionsuggestions/top.json?t=week&limit=30",
        "options": {
          "timeout": 15000
        }
      },
      "id": "fetch-tv-suggestions",
      "name": "Fetch r/TelevisionSuggestions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 500]
    },
    {
      "parameters": {
        "jsCode": "// Parse Reddit response\nconst suggestions = [];\nconst data = $input.item.json;\n\nif (data.data && data.data.children) {\n  data.data.children.forEach(child => {\n    const post = child.data;\n    \n    // Extract title and clean it\n    let title = post.title;\n    let suggestion = '';\n    \n    // Try to extract movie/show name from brackets or quotes\n    const bracketMatch = title.match(/\\[([^\\]]+)\\]/);\n    const quoteMatch = title.match(/\"([^\"]+)\"/);\n    \n    if (bracketMatch) {\n      suggestion = bracketMatch[1];\n    } else if (quoteMatch) {\n      suggestion = quoteMatch[1];\n    } else {\n      suggestion = title;\n    }\n    \n    suggestions.push({\n      title: post.title,\n      suggestion: suggestion,\n      url: `https://reddit.com${post.permalink}`,\n      subreddit: post.subreddit,\n      upvotes: post.ups,\n      comments: post.num_comments,\n      text: post.selftext || '',\n      created: post.created_utc\n    });\n  });\n}\n\nreturn suggestions.map(item => ({ json: item }));"
      },
      "id": "parse-reddit",
      "name": "Parse Reddit Posts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 350]
    },
    {
      "parameters": {
        "jsCode": "// Hermetic Quality Filter\nconst item = $input.item.json;\n\n// Positive signals (quality content)\nconst positiveSignals = [\n  'masterpiece', 'brilliant', 'must watch', 'recommend',\n  'underrated', 'hidden gem', 'classic',\n  'cinematography', 'acting', 'directing',\n  'emotional', 'thought-provoking', 'beautifully'\n];\n\n// Negative signals (low quality, spoilers, etc)\nconst negativeSignals = [\n  'spoiler', 'unpopular opinion', 'overrated',\n  'worst', 'terrible', 'boring', 'waste of time',\n  'click here', 'link in bio'\n];\n\nconst text = (item.title + ' ' + item.text).toLowerCase();\n\nlet positiveScore = 0;\nlet negativeScore = 0;\n\npositiveSignals.forEach(signal => {\n  if (text.includes(signal)) positiveScore++;\n});\n\nnegativeSignals.forEach(signal => {\n  if (text.includes(signal)) negativeScore++;\n});\n\n// Quality thresholds\nconst meetsUpvoteThreshold = item.upvotes >= 100;\nconst hasDiscussion = item.comments >= 10;\n\nreturn {\n  json: {\n    ...item,\n    positiveScore: positiveScore,\n    negativeScore: negativeScore,\n    shouldInclude: negativeScore === 0 && meetsUpvoteThreshold && hasDiscussion\n  }\n};"
      },
      "id": "filter-quality",
      "name": "Apply Quality Filter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 350]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.shouldInclude }}",
              "value2": true
            }
          ]
        }
      },
      "id": "filter-threshold",
      "name": "Filter Threshold",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 1,
      "position": [1050, 350]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate and categorize\nconst allItems = $input.all().map(item => item.json);\n\nif (allItems.length === 0) {\n  return {\n    json: {\n      hasContent: false,\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n\n// Sort by positive score and upvotes\nconst sorted = allItems.sort((a, b) => {\n  if (b.positiveScore !== a.positiveScore) {\n    return b.positiveScore - a.positiveScore;\n  }\n  return b.upvotes - a.upvotes;\n});\n\n// Categorize by subreddit\nconst movies = sorted.filter(i => i.subreddit === 'MovieSuggestions').slice(0, 3);\nconst netflix = sorted.filter(i => i.subreddit === 'NetflixBestOf').slice(0, 2);\nconst tv = sorted.filter(i => i.subreddit === 'televisionsuggestions').slice(0, 2);\n\nreturn {\n  json: {\n    hasContent: true,\n    movies: movies,\n    netflix: netflix,\n    tv: tv,\n    totalScanned: allItems.length,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "aggregate-watchlist",
      "name": "Aggregate Watchlist",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 350]
    },
    {
      "parameters": {
        "jsCode": "// Format for Telegram\nconst data = $input.item.json;\n\nif (!data.hasContent) {\n  const message = `沁ｬ **WEEKEND WATCHLIST**\\n\\n` +\n    `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n` +\n    `沒 **QUIET WEEK**\\n\\n` +\n    `No standout recommendations this week.\\n` +\n    `Time to revisit your classics!\\n\\n` +\n    `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n` +\n    `笨 **SUGGESTIONS**\\n\\n` +\n    `窶｢ Rewatch a favorite\\n` +\n    `窶｢ Explore your watchlist\\n` +\n    `窶｢ Browse by director/actor\\n` +\n    `窶｢ Try a genre you usually skip\\n\\n` +\n    `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n` +\n    `汳ｭ *\"Sometimes the best choice is no choice\"*\\n\\n` +\n    `Next watchlist: Next Friday 6 PM ET\\n`;\n  \n  return {\n    json: {\n      message: message\n    }\n  };\n}\n\n// Has content\nlet message = `沁ｬ **WEEKEND WATCHLIST**\\n`;\nmessage += `Curated Recommendations\\n\\n`;\n\nif (data.movies.length > 0) {\n  message += `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n`;\n  message += `沁･ **MOVIES** (${data.movies.length})\\n\\n`;\n  \n  data.movies.forEach((item, i) => {\n    message += `${i + 1}. **${item.suggestion}**\\n`;\n    if (item.text && item.text.length > 0) {\n      message += `   ${item.text.substring(0, 150).trim()}...\\n`;\n    }\n    message += `   汨 ${item.upvotes} upvotes | 汳ｬ ${item.comments} comments\\n`;\n    message += `   沐 [Discussion](${item.url})\\n\\n`;\n  });\n}\n\nif (data.netflix.length > 0) {\n  message += `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n`;\n  message += `沒ｺ **NETFLIX** (${data.netflix.length})\\n\\n`;\n  \n  data.netflix.forEach((item, i) => {\n    message += `${i + 1}. **${item.suggestion}**\\n`;\n    if (item.text && item.text.length > 0) {\n      message += `   ${item.text.substring(0, 150).trim()}...\\n`;\n    }\n    message += `   汨 ${item.upvotes} upvotes\\n`;\n    message += `   沐 [Discussion](${item.url})\\n\\n`;\n  });\n}\n\nif (data.tv.length > 0) {\n  message += `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n`;\n  message += `沒｡ **TV SHOWS** (${data.tv.length})\\n\\n`;\n  \n  data.tv.forEach((item, i) => {\n    message += `${i + 1}. **${item.suggestion}**\\n`;\n    if (item.text && item.text.length > 0) {\n      message += `   ${item.text.substring(0, 150).trim()}...\\n`;\n    }\n    message += `   汨 ${item.upvotes} upvotes\\n`;\n    message += `   沐 [Discussion](${item.url})\\n\\n`;\n  });\n}\n\nmessage += `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n`;\nmessage += `沁ｯ **QUALITY FILTER**\\n\\n`;\nmessage += `Scanned ${data.totalScanned} recommendations\\n`;\nmessage += `Filtered by community consensus\\n`;\nmessage += `No spoilers, no trash\\n\\n`;\n\nmessage += `笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏≫煤笏―\n`;\nmessage += `汳ｭ *\"Watch intentionally, not endlessly\"*\\n\\n`;\nmessage += `Next watchlist: Next Friday 6 PM ET\\n`;\n\nreturn {\n  json: {\n    message: message\n  }\n};"
      },
      "id": "format-telegram",
      "name": "Format for Telegram",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 350]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.telegram.org/bot8005622076:AAGwEKcZHWokqyHY8c711D1Rs9r97dbEErs/sendMessage",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={ \"chat_id\": \"1540112442\", \"text\": \"{{ $json.message }}\", \"parse_mode\": \"Markdown\", \"disable_web_page_preview\": true }"
      },
      "id": "send-telegram",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1650, 350]
    }
  ],
  "connections": {
    "Friday Watchlist (6 PM ET)": {
      "main": [[
        { "node": "Fetch r/MovieSuggestions", "type": "main", "index": 0 },
        { "node": "Fetch r/NetflixBestOf", "type": "main", "index": 0 },
        { "node": "Fetch r/TelevisionSuggestions", "type": "main", "index": 0 }
      ]]
    },
    "Fetch r/MovieSuggestions": {
      "main": [[{ "node": "Parse Reddit Posts", "type": "main", "index": 0 }]]
    },
    "Fetch r/NetflixBestOf": {
      "main": [[{ "node": "Parse Reddit Posts", "type": "main", "index": 0 }]]
    },
    "Fetch r/TelevisionSuggestions": {
      "main": [[{ "node": "Parse Reddit Posts", "type": "main", "index": 0 }]]
    },
    "Parse Reddit Posts": {
      "main": [[{ "node": "Apply Quality Filter", "type": "main", "index": 0 }]]
    },
    "Apply Quality Filter": {
      "main": [[{ "node": "Filter Threshold", "type": "main", "index": 0 }]]
    },
    "Filter Threshold": {
      "main": [[{ "node": "Aggregate Watchlist", "type": "main", "index": 0 }]]
    },
    "Aggregate Watchlist": {
      "main": [[{ "node": "Format for Telegram", "type": "main", "index": 0 }]]
    },
    "Format for Telegram": {
      "main": [[{ "node": "Send to Telegram", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
