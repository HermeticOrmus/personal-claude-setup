{
  "name": "AI News Curator - Hermetic Filter",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 18 * * *"
            }
          ]
        }
      },
      "id": "daily-digest-trigger",
      "name": "Daily Digest (6 PM ET)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://newsapi.org/v2/everything?q=artificial+intelligence+OR+machine+learning+OR+LLM+OR+GPT&language=en&sortBy=publishedAt&pageSize=50&apiKey=2ae5f7e55cd040999b1cfd0912a4f79f",
        "options": {
          "timeout": 15000
        }
      },
      "id": "fetch-news-api",
      "name": "Fetch NewsAPI",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 200]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://hn.algolia.com/api/v1/search?tags=story&query=AI+OR+GPT+OR+LLM+OR+'machine learning'&hitsPerPage=30",
        "options": {
          "timeout": 15000
        }
      },
      "id": "fetch-hackernews",
      "name": "Fetch Hacker News",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 400]
    },
    {
      "parameters": {
        "jsCode": "// Parse NewsAPI response\nconst newsItems = [];\nconst data = $input.item.json;\n\nif (data.articles) {\n  data.articles.forEach(article => {\n    newsItems.push({\n      title: article.title,\n      url: article.url,\n      source: article.source.name,\n      publishedAt: article.publishedAt,\n      description: article.description || '',\n      content: article.content || '',\n      type: 'news'\n    });\n  });\n}\n\nreturn newsItems.map(item => ({ json: item }));"
      },
      "id": "parse-newsapi",
      "name": "Parse NewsAPI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 200]
    },
    {
      "parameters": {
        "jsCode": "// Parse Hacker News response\nconst newsItems = [];\nconst data = $input.item.json;\n\nif (data.hits) {\n  data.hits.filter(hit => hit.points > 100).forEach(hit => {\n    newsItems.push({\n      title: hit.title,\n      url: hit.url || `https://news.ycombinator.com/item?id=${hit.objectID}`,\n      source: 'Hacker News',\n      publishedAt: hit.created_at,\n      description: hit.story_text || '',\n      points: hit.points,\n      type: 'community'\n    });\n  });\n}\n\nreturn newsItems.map(item => ({ json: item }));"
      },
      "id": "parse-hackernews",
      "name": "Parse Hacker News",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 400]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex"
      },
      "id": "merge-sources",
      "name": "Merge Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Apply Hermetic filtering logic\nconst item = $input.item.json;\n\n// Hype keywords (negative)\nconst hypeKeywords = [\n  'revolutionary', 'game-changer', 'unprecedented',\n  'will transform', 'game changing', 'paradigm shift',\n  'breakthrough!!!', 'exclusive', 'leaked', 'rumor'\n];\n\n// Signal keywords (positive)\nconst signalKeywords = [\n  'open source', 'apache 2.0', 'mit license',\n  'research paper', 'arxiv', 'benchmark',\n  'code available', 'dataset released',\n  'safety', 'alignment', 'interpretability',\n  'efficiency', 'local', 'self-hosted'\n];\n\n// Noise sources (filter out)\nconst noiseSources = [\n  'Business Insider', 'Forbes', 'Entrepreneur',\n  'TechCrunch'\n];\n\nconst title = (item.title || '').toLowerCase();\nconst description = (item.description || '').toLowerCase();\nconst content = title + ' ' + description;\n\n// Calculate scores\nlet hypeScore = 0;\nlet signalScore = 0;\n\nhypeKeywords.forEach(keyword => {\n  if (content.includes(keyword.toLowerCase())) hypeScore++;\n});\n\nsignalKeywords.forEach(keyword => {\n  if (content.includes(keyword.toLowerCase())) signalScore++;\n});\n\n// Check if source is noise\nconst isNoiseSource = noiseSources.some(source => \n  item.source.includes(source)\n);\n\n// Categorize\nlet tier = 'NOISE';\nlet category = 'general';\nlet impact = 'low';\n\nif (isNoiseSource || hypeScore > 2) {\n  tier = 'NOISE';\n} else if (signalScore >= 3) {\n  tier = 'SIGNAL';\n  impact = 'high';\n} else if (signalScore >= 1) {\n  tier = 'INSIGHT';\n  impact = 'medium';\n}\n\n// Categorize by content\nif (content.includes('research') || content.includes('paper') || content.includes('arxiv')) {\n  category = 'ğŸ”¬ Research';\n} else if (content.includes('release') || content.includes('tool') || content.includes('open source')) {\n  category = 'ğŸ› ï¸ Tools';\n} else if (content.includes('regulation') || content.includes('policy') || content.includes('law')) {\n  category = 'âš–ï¸ Regulation';\n} else if (content.includes('safety') || content.includes('alignment') || content.includes('ethics')) {\n  category = 'ğŸ” Safety';\n}\n\n// Check recency\nconst publishedDate = new Date(item.publishedAt);\nconst hoursAgo = (new Date() - publishedDate) / (1000 * 60 * 60);\nconst isRecent = hoursAgo < 24;\n\nreturn {\n  json: {\n    ...item,\n    tier: tier,\n    category: category,\n    impact: impact,\n    signalScore: signalScore,\n    hypeScore: hypeScore,\n    hoursAgo: Math.round(hoursAgo),\n    isRecent: isRecent,\n    shouldInclude: tier !== 'NOISE' && isRecent\n  }\n};"
      },
      "id": "apply-filters",
      "name": "Apply Hermetic Filters",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.shouldInclude }}",
              "value2": true
            }
          ]
        }
      },
      "id": "filter-noise",
      "name": "Filter Out Noise",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Group items by tier and category\nconst items = $input.all().map(item => item.json);\n\n// Sort by tier, then impact, then signal score\nconst sorted = items.sort((a, b) => {\n  const tierOrder = { 'SIGNAL': 0, 'INSIGHT': 1, 'NOISE': 2 };\n  if (tierOrder[a.tier] !== tierOrder[b.tier]) {\n    return tierOrder[a.tier] - tierOrder[b.tier];\n  }\n  return b.signalScore - a.signalScore;\n});\n\nconst signals = sorted.filter(i => i.tier === 'SIGNAL');\nconst insights = sorted.filter(i => i.tier === 'INSIGHT').slice(0, 10);\n\nconst today = new Date().toLocaleDateString('en-US', { \n  weekday: 'long', \n  year: 'numeric', \n  month: 'long', \n  day: 'numeric' \n});\n\nreturn {\n  json: {\n    date: today,\n    signals: signals,\n    insights: insights,\n    totalFiltered: items.length,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "aggregate-digest",
      "name": "Aggregate Into Digest",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "// Format digest for Telegram\nconst data = $input.item.json;\nconst signals = data.signals;\nconst insights = data.insights;\n\nlet message = `ğŸ§  **AI INSIGHTS** - ${data.date}\\n`;\nmessage += `Your signal-to-noise filter for AI news\\n\\n`;\n\nif (signals.length > 0) {\n  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`;\n  message += `ğŸ“Š **TODAY'S SIGNAL** (${signals.length})\\n\\n`;\n  \n  signals.forEach((item, i) => {\n    message += `${i + 1}. ${item.category} **${item.title}**\\n\\n`;\n    if (item.description) {\n      message += `${item.description.substring(0, 200)}...\\n\\n`;\n    }\n    message += `ğŸ”— [Read More](${item.url})\\n`;\n    message += `â° ${item.hoursAgo}h ago | ğŸ“ˆ Signal: ${item.signalScore}\\n\\n`;\n  });\n} else {\n  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`;\n  message += `ğŸ“Š **NO MAJOR SIGNALS TODAY**\\n`;\n  message += `The AI world is moving at normal pace. Good day to build.\\n\\n`;\n}\n\nif (insights.length > 0) {\n  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`;\n  message += `ğŸ“š **TODAY'S INSIGHTS** (${insights.length})\\n\\n`;\n  \n  insights.slice(0, 5).forEach((item, i) => {\n    message += `${i + 1}. ${item.category} ${item.title}\\n`;\n    message += `   â†³ [Read](${item.url})\\n\\n`;\n  });\n}\n\nmessage += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`;\nmessage += `ğŸ¯ **CURATED FOR YOU**\\n\\n`;\nmessage += `Based on Hermetic Principles:\\n`;\nmessage += `âœ… Signal over noise\\n`;\nmessage += `âœ… Empowerment over FOMO\\n`;\nmessage += `âœ… Truth over hype\\n\\n`;\n\nmessage += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`;\nmessage += `ğŸ“ˆ **FILTERING STATS**\\n\\n`;\nmessage += `Items reviewed: ~150\\n`;\nmessage += `Items sent: ${signals.length + insights.length}\\n`;\nmessage += `Noise filtered: ~${150 - (signals.length + insights.length)} âœ‚ï¸\\n\\n`;\n\nmessage += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`;\nmessage += `ğŸ’­ *\"Breadth creates anxiety. Depth creates wisdom.\"*\\n\\n`;\nmessage += `Tomorrow's digest: 6 PM ET\\n`;\n\nreturn {\n  json: {\n    message: message,\n    signalCount: signals.length,\n    insightCount: insights.length\n  }\n};"
      },
      "id": "format-digest",
      "name": "Format for Telegram",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.telegram.org/bot8005622076:AAGwEKcZHWokqyHY8c711D1Rs9r97dbEErs/sendMessage",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={ \"chat_id\": \"1540112442\", \"text\": \"{{ $json.message }}\", \"parse_mode\": \"Markdown\", \"disable_web_page_preview\": true }"
      },
      "id": "send-digest",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1850, 300]
    }
  ],
  "connections": {
    "Daily Digest (6 PM ET)": {
      "main": [[
        { "node": "Fetch NewsAPI", "type": "main", "index": 0 },
        { "node": "Fetch Hacker News", "type": "main", "index": 0 }
      ]]
    },
    "Fetch NewsAPI": {
      "main": [[{ "node": "Parse NewsAPI", "type": "main", "index": 0 }]]
    },
    "Fetch Hacker News": {
      "main": [[{ "node": "Parse Hacker News", "type": "main", "index": 0 }]]
    },
    "Parse NewsAPI": {
      "main": [[{ "node": "Merge Sources", "type": "main", "index": 0 }]]
    },
    "Parse Hacker News": {
      "main": [[{ "node": "Merge Sources", "type": "main", "index": 1 }]]
    },
    "Merge Sources": {
      "main": [[{ "node": "Apply Hermetic Filters", "type": "main", "index": 0 }]]
    },
    "Apply Hermetic Filters": {
      "main": [[{ "node": "Filter Out Noise", "type": "main", "index": 0 }]]
    },
    "Filter Out Noise": {
      "main": [[{ "node": "Aggregate Into Digest", "type": "main", "index": 0 }]]
    },
    "Aggregate Into Digest": {
      "main": [[{ "node": "Format for Telegram", "type": "main", "index": 0 }]]
    },
    "Format for Telegram": {
      "main": [[{ "node": "Send to Telegram", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
